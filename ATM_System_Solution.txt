==============================================================================
                        ATM SYSTEM ASSIGNMENT SOLUTION
==============================================================================

Developer: Yuval Gorodissky
Project: Software Engineer - ATM System
Completion Date: 2025

==============================================================================
                              PROJECT OVERVIEW
==============================================================================

This document contains the complete solution for the ATM System assignment, 
including detailed explanations of approach, design decisions, challenges 
faced, and instructions for execution.

==============================================================================
                            PROJECT INFORMATION
==============================================================================

REPOSITORY & LINKS:
- Git Repository: https://github.com/yuvalgorodissky/ATM_System
- Live Production API: http://56.228.41.210:8000 (AWS EC2 Instance)
- API Documentation: http://56.228.41.210:8000/docs
- Interactive Testing: http://56.228.41.210:8000/redoc
- Hosting: AWS EC2 Instance

ASSIGNMENT REQUIREMENTS FULFILLED:
✓ Server-side ATM system implementation
✓ In-memory data storage
✓ GET /accounts/{account_number}/balance endpoint
✓ POST /accounts/{account_number}/withdraw endpoint  
✓ POST /accounts/{account_number}/deposit endpoint
✓ Cloud deployment (Production server running)
✓ Comprehensive documentation
✓ Git repository with version control

==============================================================================
                        APPROACH & DESIGN DECISIONS
==============================================================================

ARCHITECTURAL APPROACH:

1. **Singleton Pattern for Bank Management**
   - Rationale: Ensure single source of truth for all banking operations
   - Implementation: Thread-safe singleton with double-checked locking
   - Benefits: Prevents multiple bank instances, ensures data consistency

2. **Account-Level Thread Safety**
   - Rationale: Support concurrent operations while maintaining data integrity
   - Implementation: Individual threading.Lock() for each account
   - Benefits: Different accounts can be accessed simultaneously, prevents race conditions

3. **FastAPI Framework Selection**
   - Rationale: Modern, fast, automatic API documentation, type hints support
   - Benefits: Built-in validation, async support, interactive documentation

4. **Router-Based Architecture**
   - Rationale: Modular code organization, separation of concerns
   - Implementation: Separate routers for different API functionalities
   - Benefits: Easier maintenance, scalable structure

5. **Configuration Management System**
   - Rationale: Support multiple deployment environments
   - Implementation: YAML-based config with environment variable overrides
   - Benefits: Easy deployment, no code changes between environments

TECHNICAL DECISIONS:

**Data Storage:**
- Decision: In-memory dictionary storage
- Rationale: Assignment requirement, simplicity, fast access
- Trade-off: No persistence (acceptable for demo)

**Input Validation:**
- Decision: Pydantic models for request/response validation
- Rationale: Automatic validation, clear error messages, type safety
- Benefits: Prevents invalid data, consistent API responses

**Error Handling:**
- Decision: HTTP status codes with descriptive messages
- Implementation: 200 (success), 400 (bad request), 404 (not found)
- Benefits: RESTful design, clear error communication

==============================================================================
                           CHALLENGES & SOLUTIONS
==============================================================================

CHALLENGE 1: Thread Safety
Problem: Concurrent requests could cause race conditions in account operations
Solution: Implemented account-level locking with threading.Lock()
Result: Thread-safe operations while allowing concurrent access to different accounts

CHALLENGE 2: Circular Import Dependencies  
Problem: Router needed Bank access, creating circular imports
Solution: Singleton pattern allowing direct access without circular dependencies
Result: Clean architecture without import issues

CHALLENGE 3: Configuration Management
Problem: Supporting multiple environments (development/production)
Solution: YAML-based configuration with environment variable overrides
Result: Easy deployment across different environments

CHALLENGE 4: Data Initialization
Problem: Need initial account data while maintaining in-memory storage
Solution: File-based initialization that loads accounts at startup
Result: Flexible account setup while meeting in-memory requirement

CHALLENGE 5: API Consistency
Problem: Ensuring consistent response formats across endpoints
Solution: Pydantic models for standardized request/response structures
Result: Consistent, validated API responses with clear documentation


SYSTEM ASSUMPTIONS:
- Fixed account base of 3 accounts only
- Account-centric operations (focus on account numbers)
- Simple account structure for demonstration
- No user registration/management in current implementation
- No persistence layer (in-memory only)
- No authentication/authorization for users
